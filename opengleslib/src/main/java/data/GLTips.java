package data;

import filter.img.WaterMarkFilter;
import util.GLUtil;

public interface GLTips
{
    /**
     * 这个类仅记录一些个人的理解、认知，不是一定正确
     *
     * 1、Open GL 的坐标轴是 三维 的，x\y\z ，而且是右手法则，右手掌心面向自己，分别的正方向是 x: 大拇指向右的方向 ， y: 食指向上的方向， z: 中指指向自己的方向
     *
     * 2、Open GL 最终呈现在手机屏幕上的内容，其实就是近平面所能观察到的内容 (在 三维坐标系 (世界坐标系) 中 被定义的一个平面)
     *
     *      定义的 顶点坐标(x, y, z) 每个轴的取值范围，其实并非一定是 [-1, 1], 可以是 任何数值, 实际上顶点坐标对应的是 三维坐标系 中的点
     *      网上很多资料都定义 [-1, 1] 的原因 : 一般的博客代码, 近平面 的 (left, right, bottom, top) 都会定义成 (-屏幕宽高比, 屏幕宽高比, -1, 1) or (-1, 1, -1 / 屏幕宽高比, 1 / 屏幕宽高比)
     *      那么实际上, 在三维坐标系中的近平面大小就是 (-屏幕宽高比, 屏幕宽高比, -1, 1) --> (-1 * 比例, 1 * 比例, -1, 1), 这样 [-1, 1] 总会是某一个轴上的顶点
     *
     * 3、但是 Open GL 是三维的，手机屏幕是二维，那么，呈现的内容必然会经过坐标系、点的映射：
     *      Open GL 三维坐标上的点，首先会被映射到 一个标准的立方体(边长：2, 三个轴的坐标范围都是 [-1, 1]){ https://blog.csdn.net/wangdingqiaoit/article/details/51589825 }
     *      其中，立方体是不变的 (这个立方体的坐标系，也叫归一化坐标), 立方体有三个轴，x'\y'\z'， 其中原点 (0, 0, 0) 是在 立方体 内部中心
     *      并且 立方体 的坐标系，是左手法则，左手手背面向自己，分别的正方向是: x: 大拇指向右的方向， y : 食指向上的方向， z: 中指指向 眼睛看东西的方向
     *
     *      ~~~~ 而 近平面 与 立方体 的关系， 我的理解是：将 近平面 压缩 进 立方体中（宽高非等比例压缩）
     *
     *      近平面的 left\right 映射到 立方体x'轴 的 [-1, 1], 近平面的 bottom\top 映射到 立方体y'轴的 [-1, 1], 近平面的 near\ 远平面 far 映射到 立方体z'轴的 [-1, 1]
     *      经过 三维 --> 二维 的变换、映射后, 在立方体中的点，就是最终要画到屏幕上的点
     *
     * 4、
     *  视口是一个矩形窗口区域。是OpenGL渲染操作最终显示的地方
     *  x, y 是渲染的起点，0，0 是屏幕左下角
     *  GLES20.glViewport(0, 0, width, height);
     *  float sWidthHeight = width / (float) height;
     *  Matrix.frustumM(f, 0, -10f, 10f, -10f / sWidthHeight, 10f / sWidthHeight, 3.0f, 5.0f);
     *      参数：
     *      {
     *          Matrix f: 用来接收数据的矩阵
     *          int offset: 矩阵中接收数据的起始位置偏移量
     *          // 近平面 其实是一个 矩形, ( 近平面 应该理解为 三维空间中的平面 )
     *          // 下面是决定近平面大小(面积、形状、宽高比例) 的四个参数, left\right\bottom\top 是基于 x|y 轴 的参数
     *          // 以下 4 个点都是基于 近平面 中心点讨论 ( 数值上，可以是任何数值，不一定是 -1f -> 1f 如上述例子)
     *          // x\y 轴的参数
     *          float left: 以中心点为基础的左边距 --> 负数
     *          float right: 以中心点为基础的右边距 --> 正数
     *          float bottom: 以中心点为基础的下边距 --> 负数
     *          float top: 以中心点为基础的上边距 --> 正数
     *
     *          // near\far 是基于 z 轴的参数, 只有处于 远近平面 之间的物体，才是可见的
     *          float near: 近平面 在 z 轴的位置
     *          float far: 远平面 在 z 轴的位置
     *      }
     *
     * 5、https://blog.csdn.net/junzia/article/details/52830604 解释 GLSL 语言
     * 其中，个人觉得比较重要的点:
     *      5-1 需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反） 建议结合 {@link OpenGLES# 维基百科 -- 矩阵} 来理解
     *      5-2
     *          纹理采样函数
     *          纹理采样函数有
     *              texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod、
     *              texture3D、texture3DProj、texture3DLod、texture3DProjLod等。
     *
     *          texture表示纹理采样，2D表示对2D纹理采样，3D表示对3D纹理采样
     *          Lod后缀，只适用于顶点着色器采样
     *          Proj表示纹理坐标st会除以q
     *          纹理采样函数中，3D在OpenGLES2.0并不是绝对支持
     *          texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。
     *
     * 6、对画 texture2D 图片，透视矩阵的理解，
     *
     *      前提：假设 目前有一张图片(宽: 1080  高: 540) 需要显示在手机屏幕 (宽: 1080  高: 2160) 上,
     *           顶点坐标(-1, 1, 0,
     *                   1, 1, 0,
     *                   1, -1, 0,
     *                   -1, -1, 0)
     *           sWH 是 图片的宽高比, sWidthHeight 是预览区域的宽高比 {@link GLUtil#getFrustumM(float[], int, int, int, int)}
     *
     *      要求：图片不能被拉伸、压缩、变形
     *
     *      处理方法: 在网上看的资料，透视矩阵一般这样设置 Matrix.frustumM(projectMatrix, 0, -1, 1, -sWH / sWidthHeight, sWH / sWidthHeight, 3, 5);
     *
     *      问题(有疑惑的点): 为什么 近平面 宽是 2，高是 2 * sWH / sWidthHeight, 而不是 2 / sWidthHeight, 为什么要再 乘以一个 图片的宽高比 ？？？？？？
     *
     *      个人理解:
     *      这里需要结合 三维世界坐标 和 归一化坐标 一起来推导：
     *
     *      由于上述方法是设置 三维世界坐标系 近平面 的宽高，那么此时 不能被确定的就是 三维世界坐标系 中 近平面 的真实高度 n, 那应该如何计算出需要的高度？
     *
     *      首先我们要考虑到，当前的已知条件是：
     *           a：图片的宽高比 sWH
     *           b: 近平面(归一化坐标系中)的宽度 x, 近平面(归一化坐标系中)的高度 y
     *           c: 归一化坐标系中 x:y = sWidthHeight
     *
     *      变量：
     *          1、归一化坐标系中，图片在y轴正方向的高度 Iyh;
     *
     *      分析：(以下只是讨论正方向)
     *      通过 已知条件 a, b ，求得 Iyh = x * 1 / sWH
     *      因为 三维坐标系的点都是通过 映射，跟 归一化坐标系一一对应，所以 Iyh / y = 1 / n   (其中 1 / n 的 1 是顶点坐标 y = 1)
     *      代入具体数值后求得 n = sWH / sWidthHeight;
     *
     * 7、 继续 第6点 的补充， 对 画 texture2D 图片，矩阵的使用理解
     *
     *     依然是 第6点 的前提、要求
     *
     *     处理方法：写死透视矩阵的大小(其实是写死 近平面 在三维坐标系的大小)，
     *     然后额外用一个矩阵，对图片进行下面的操作：
     *          三维空间的缩放(缩放成图片原来比例)
     *          三维空间的平移(由于矩阵内的值，并非通过矩阵互乘得到，是直接赋值到数组，所以平移的时候，要考虑之前是否有经过缩放操作)
     *          三维空间的旋转
     *          个人感觉这种方法比较好理解 {@link gles.Gles7View#onSurfaceChanged} or {@link WaterMarkFilter#onDrawSelf() 画底图和水印的算法}
     */
}
