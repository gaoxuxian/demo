package data;

public interface GLTips
{
    /**
     * 这个类仅记录一些个人的理解、认知，不是一定正确
     *
     * 1、Open GL 的坐标轴是 三维 的，x\y\z ，而且是右手法则，右手掌心面向自己，分别的正方向是 x: 大拇指向右的方向 ， y: 食指向上的方向， z: 中指指向自己的方向
     *
     * 2、定义的 顶点坐标(x, y, z) 每个轴的取值范围，其实并非一定是 [-1, 1], 可以是 任何数值, 实际上顶点坐标对应的是 三维坐标系 中的点
     *          网上很多资料都定义 [-1, 1] 的原因 : 一般的博客代码, 近平面 的 (left, right, bottom, top) 都会定义成 (-屏幕宽高比, 屏幕宽高比, -1, 1) or (-1, 1, -1 / 屏幕宽高比, 1 / 屏幕宽高比)
     *          那么实际上, 在三维坐标系中的近平面大小就是 (-屏幕宽高比, 屏幕宽高比, -1, 1) --> (-1 * 比例, 1 * 比例, -1, 1), 这样 [-1, 1] 总会是某一个轴上的顶点
     *
     * 2、Open GL 最终呈现在手机屏幕上的内容，其实就是近平面所能观察到的内容 (在 三维坐标系 (世界坐标系) 中 被定义的一个平面)
     *
     * 3、但是 Open GL 是三维的，手机屏幕是二维，那么，呈现的内容必然会经过坐标系、点的映射：
     *      Open GL 三维坐标上的点，首先会被映射到 一个标准的立方体(边长：2, 三个轴的坐标范围都是 [-1, 1]){ https://blog.csdn.net/wangdingqiaoit/article/details/51589825 }
     *      其中，立方体是不变的 (这个立方体的坐标系，也叫归一化坐标), 立方体有三个轴，x'\y'\z'， 其中原点 (0, 0, 0) 是在 立方体 内部中心
     *      并且 立方体 的坐标系，是左手法则，左手手背面向自己，分别的正方向是: x: 大拇指向右的方向， y : 食指向上的方向， z: 中指指向 眼睛看东西的方向
     *
     *      ~~~~ 而 近平面 与 立方体 的关系， 我的理解是：将 近平面 压缩 进 立方体中（宽高非等比例压缩）
     *
     *      近平面的 left\right 映射到 立方体x'轴 的 [-1, 1], 近平面的 bottom\top 映射到 立方体y'轴的 [-1, 1], 近平面的 near\ 远平面 far 映射到 立方体z'轴的 [-1, 1]
     *      经过 三维 --> 二维 的变换、映射后, 在立方体中的点，就是最终要画到屏幕上的点
     *
     * 4、
     *  视口是一个矩形窗口区域。是OpenGL渲染操作最终显示的地方
     *  x, y 是渲染的起点，0，0 是屏幕左上角
     *  GLES20.glViewport(0, 0, width, height);
     *  float sWidthHeight = width / (float) height;
     *  Matrix.frustumM(f, 0, -10f, 10f, -10f / sWidthHeight, 10f / sWidthHeight, 3.0f, 5.0f);
     *      参数：
     *      {
     *          Matrix f: 用来接收数据的矩阵
     *          int offset: 矩阵中接收数据的起始位置偏移量
     *          // 近平面 其实是一个 矩形, ( 近平面 应该理解为 三维空间中的平面 )
     *          // 下面是决定近平面大小(面积、形状、宽高比例) 的四个参数, left\right\bottom\top 是基于 x|y 轴 的参数
     *          // 以下 4 个点都是基于 近平面 中心点讨论 ( 数值上，可以是任何数值，不一定是 -1f -> 1f 如上述例子)
     *          // x\y 轴的参数
     *          float left: 以中心点为基础的左边距 --> 负数
     *          float right: 以中心点为基础的右边距 --> 正数
     *          float bottom: 以中心点为基础的下边距 --> 负数
     *          float top: 以中心点为基础的上边距 --> 正数
     *
     *          // near\far 是基于 z 轴的参数, 只有处于 远近平面 之间的物体，才是可见的
     *          float near: 近平面 在 z 轴的位置
     *          float far: 远平面 在 z 轴的位置
     *      }
     *
     * 5、https://blog.csdn.net/junzia/article/details/52830604 解释 GLSL 语言
     * 其中，个人觉得比较重要的点:
     *      5-1 需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反） 建议结合 {@link OpenGLES# 维基百科 -- 矩阵} 来理解
     *      5-2
     *          纹理采样函数
     *          纹理采样函数有
     *              texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod、
     *              texture3D、texture3DProj、texture3DLod、texture3DProjLod等。
     *
     *          texture表示纹理采样，2D表示对2D纹理采样，3D表示对3D纹理采样
     *          Lod后缀，只适用于顶点着色器采样
     *          Proj表示纹理坐标st会除以q
     *          纹理采样函数中，3D在OpenGLES2.0并不是绝对支持。我们再次暂时不管3D纹理采样函数。重点只对texture2D函数进行说明。
     *          texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。
     *
     * 6、对画 texture2D 图片，透视矩阵的理解，
     *
     *      前提：假设 目前有一张图片(宽: 1080  高: 540) 需要显示在手机屏幕 (宽: 1080  高: 2160) 上,
     *           顶点坐标(-1, 1, 0,
     *                   1, 1, 0,
     *                   1, -1, 0,
     *                   -1, -1, 0)
     *           sWH 是 图片的宽高比, sWidthHeight 是预览区域的宽高比 {@link lib.opengles.GLUtil#getFrustumM(float[], int, int, int, int)}
     *
     *      要求：图片不能被拉伸、压缩、变形
     *
     *      处理方法: 在网上看的资料，透视矩阵一般这样设置 Matrix.frustumM(projectMatrix, 0, -1, 1, -sWH / sWidthHeight, sWH / sWidthHeight, 3, 5);
     *
     *      问题(有疑惑的点): 为什么 近平面 宽是 2，高是 2 * sWH / sWidthHeight, 而不是 2 / sWidthHeight, 为什么要再 乘以一个 图片的宽高比 ？？？？？？
     *
     *      个人理解:
     *      这里需要结合 三维世界坐标 和 归一化坐标 一起来推导：
     *
     *      由于上述方法是设置 三维世界坐标系 中，近平面 的宽高，那么此时 不能被确定的就是 三维世界坐标系 中 近平面 的真实高度, 那应该如何计算出需要的高度？
     *      首先我们要考虑到，当前能固定下来、确定的数值是： a：图片的宽高比、b: 近平面(归一化坐标系中)的宽度,
     *      那么我们可以先通过 已知条件 a b , 求 在归一化坐标系中 图片的高度 (由于归一化坐标是在标准立方体中心，下面方便计算，统一计算一半的图片高度，图片全高只需乘以2)
     *      我们知道 在归一化坐标系中，y轴正方向向上，x轴正方向向右， 那么图片上半段的高度 NormalizedImageH，在归一化坐标系中，应该是 NormalizedImageH = 1 * 1 / sWH;
     *      下一步，我们就可以得到 归一化坐标系中， 图片高度的占比 r = NormalizedImageH / 1;
     *      这时，我们就需要将归一化坐标的占比 r 反推到 三维世界坐标去，从而求到 三维世界坐标系 中， 近平面的高度
     *
     *      具体做法：
     *              假设 近平面 y轴正方向的长度是 NH，那么 r = 1 / NH, 所以 NormalizedImageH / 1 = 1 / NH
     *              然后代入 NormalizedImageH = 1 * 1 / sWH, 有 1 / sWH = 1 / NH  所以 NH = sWH;
     *
     *      不过，以上结果并不是就是最终，由于 我们希望 OpenGL 画出来的区域宽高比，跟预览区域的宽高比 一致，那么就不用再做额外的变换，
     *      即使归一化坐标系中， x、y、z 正方向都是1，但是 x:y 真实的比例，应该是 sWidthHeight
     *      所以 NH 需要 乘以 1 / sWidthHeight
     *
     * 7、 继续 第6点 的补充， 对 画 texture2D 图片，矩阵的使用理解
     *
     *      依然是 第6点 的前提、要求
     *
     *      处理方法：写死透视矩阵的大小，然后额外用一个矩阵，对图片进行缩放、平移、旋转，个人感觉这种方法比较好理解 {@link gles.Gles7View#onSurfaceChanged}
     */
}
