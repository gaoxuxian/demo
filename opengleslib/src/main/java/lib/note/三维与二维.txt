
    Open GL 的坐标轴是 三维 的，x\y\z ，而且是右手法则，右手掌心面向自己，分别的正方向是 x: 大拇指向右的方向 ， y: 食指向上的方向， z: 中指指向自己的方向

    手机屏幕是二维坐标系, surface 中心, 对应于 Open GL 三维坐标系的原点

    Open GL 最终呈现在手机屏幕上的内容的范围, 是近平面大小决定的, 它实际上是在 三维坐标系 (世界坐标系) 中的一个平面, 三维世界的相机镜头透过它, 观察事物

    但是要怎么将 三维 的事物 画到 二维的屏幕上呢? 这里需要引入两个概念 --> 映射、归一化坐标系 {@link https://blog.csdn.net/wangdingqiaoit/article/details/51589825}

    归一化坐标系，其实就是我们的手机屏幕，它是一个 长宽高 都是 2 的 立方体, 坐标系原点 在 立方体中心,
        并且坐标系是左手法则，左手手背面向自己，分别的正方向是: x: 大拇指向右的方向， y : 食指向上的方向， z: 中指指向 眼睛看东西的方向

    那么映射, 就是 将三维坐标系中 定义的 一个 长方体(被观察的事物，位于长方体内部), 按点映射到 归一化坐标系 的立方体上, 那么要怎么在三维坐标系中定义一个长方体呢?

    长方体，需要几个要素组成: 近平面、远平面、相机

    =========================================== 由于 透视 和 正交 是同样的原理, 下面只分析 透视 ====================================================

    相机
            setLookAtM(float[] rm, int rmOffset,
                        float eyeX, float eyeY, float eyeZ,
                        float centerX, float centerY, float centerZ, float upX, float upY,
                        float upZ)

     参数:
         {
            float[] rm : 接受相机参数的数组
            int rmOffset : 从数据开始纪录的下标偏移量

            // 相机的位置, x\y\z 轴, z值会影响 近平面、远平面 的位置
            float eyeX:
            float eyeY:
            float eyeZ:

            // 相机的中心点
            float centerX:
            float centerY:
            float centerZ:

            // 相机镜头的正方向:
            float upX:
            float upY:
            float upZ:
         }

    =============================================================================================================================================

    相信很多同学在看网上博客，都看过这句代码, glViewport(0, 0, getSurfaceW(), getSurfaceH()); 那么它是做什么用的呢?

    Viewport == 视口, 视口是一个矩形窗口区域, 是 GL 绘制命令最终绘制的区域( 渲染操作最终显示的地方 )。
        x, y 是渲染的起点, 0,0 是 surface 的左下角, getSurfaceW(), getSurfaceH() 是 surface 的右上角

    viewport 的大小、位置, 是可以根据需要, 随时更改的!

    视口也是决定 归一化坐标系, x轴、y轴 [-1,1] 这个区域大小的关键, 为什么这么说? 因为在不考虑z 轴的情况下，视口所代表的就是 立方体( 归一化坐标系 )的正面

    ============================================================================================================================================

    近平面 (三维坐标系中的一个平面) ---> 在三维映射二维的逻辑中，它的 左上角 映射 到 立方体( 归一化坐标 ) 的左上角, 其他角同理。

    下面这句代码, 是定义 三维坐标系中 近平面大小、位置, 远平面大小、位置的

    Matrix.frustumM(f, offset, left, right, bottom, top, near, far);

    参数:
        {
            Matrix f: 用来接收数据的矩阵
            int offset: 矩阵中接收数据的起始位置偏移量

            // 近平面 其实是一个 矩形, ( 近平面 应该理解为 三维空间中的平面 )
            // 下面是决定近平面大小(宽高比例) 的四个参数, left\right\bottom\top 是基于 x|y 轴 的参数
            // 以下 4 个点都是基于 近平面 中心点讨论 ( 数值上，可以是任何数值，不一定是 -1f -> 1f, 可以是三维坐标系中x、y轴上任意一个值)
            // x\y 轴的参数
            float left: 以中心点为基础的左边距 --> 负数
            float right: 以中心点为基础的右边距 --> 正数
            float bottom: 以中心点为基础的下边距 --> 负数
            float top: 以中心点为基础的上边距 --> 正数

            // near\far 是基于 z 轴的参数, 只有处于 远近平面 之间的物体，才是可见的
            float near: 近平面 在 z 轴上的位置与相机 z 轴位置 相差的距离, 与 相机 eyeZ 有关
            float far: 远平面 在 z 轴上的位置与相机 z 轴位置 相差的距离, 与 相机 eyeZ 有关
        }

    一般情况下, 如果不设置这个方法, gl 会有一个 默认近平面(至于默认远平面, 我暂时也不太清楚它的位置, 可能是无限远...), 这个默认近平面的宽[-1, 1], 高[-1, 1], 位置 z == 0;

    就我而言, 定义 近平面 大小 的时候，如无必要，一般会定义成 跟 viewport 宽高比一致, 为什么? 主要是为了更好理解换算逻辑, 因为 近平面 跟 viewport 设置的区域, 是一一对应的关系, 仅此而已!
    我比较倾向于, 直观去理解映射逻辑, 所谓的直观就是, 我希望这个物体在二维屏幕中, 是什么样的, 在三维坐标系中, 它也是什么样的( 读起来可能比较绕, 尽量理解吧, 每个人的思路都不一样 )

    =============================================================================================================================================

    回到定义三维坐标系的 长方体 的话题上, 经过上面几步, 我们已经设置了 相机、视口、近平面、远平面, 那么由 近平面、远平面，已经可以组成一个 长方体 了，只要被画事物存在于 近平面与远平面 的空间之内,
    那么，由近平面、远平面包裹的长方体，就是需要被映射到 归一化坐标 --> 立方体 上的内容, 近平面与远平面的距离，将被映射成屏幕上的深度信息
